{"mappings":"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","sources":["node_modules/riot/riot.esm.js","src/utils/game-of-life.ts","src/utils/memoize.ts","src/components/game-of-life/game-of-life.riot","src/app.riot","src/components/main-banner/main-banner.riot","src/components/header-text/header-text.riot","src/components/game-of-life/game-cell.riot","src/components/component-background/component-background.riot","src/app.ts"],"sourcesContent":["/* Riot v6.1.2, @license MIT */\n/**\n * Convert a string from camel case to dash-case\n * @param   {string} string - probably a component tag name\n * @returns {string} component name normalized\n */\nfunction camelToDashCase(string) {\n  return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n}\n/**\n * Convert a string containing dashes to camel case\n * @param   {string} string - input string\n * @returns {string} my-string -> myString\n */\n\nfunction dashToCamelCase(string) {\n  return string.replace(/-(\\w)/g, (_, c) => c.toUpperCase());\n}\n\n/**\n * Get all the element attributes as object\n * @param   {HTMLElement} element - DOM node we want to parse\n * @returns {Object} all the attributes found as a key value pairs\n */\n\nfunction DOMattributesToObject(element) {\n  return Array.from(element.attributes).reduce((acc, attribute) => {\n    acc[dashToCamelCase(attribute.name)] = attribute.value;\n    return acc;\n  }, {});\n}\n/**\n * Move all the child nodes from a source tag to another\n * @param   {HTMLElement} source - source node\n * @param   {HTMLElement} target - target node\n * @returns {undefined} it's a void method ¯\\_(ツ)_/¯\n */\n// Ignore this helper because it's needed only for svg tags\n\nfunction moveChildren(source, target) {\n  if (source.firstChild) {\n    target.appendChild(source.firstChild);\n    moveChildren(source, target);\n  }\n}\n/**\n * Remove the child nodes from any DOM node\n * @param   {HTMLElement} node - target node\n * @returns {undefined}\n */\n\nfunction cleanNode(node) {\n  clearChildren(node.childNodes);\n}\n/**\n * Clear multiple children in a node\n * @param   {HTMLElement[]} children - direct children nodes\n * @returns {undefined}\n */\n\nfunction clearChildren(children) {\n  Array.from(children).forEach(removeChild);\n}\n/**\n * Remove a node\n * @param {HTMLElement}node - node to remove\n * @returns {undefined}\n */\n\nconst removeChild = node => node && node.parentNode && node.parentNode.removeChild(node);\n/**\n * Insert before a node\n * @param {HTMLElement} newNode - node to insert\n * @param {HTMLElement} refNode - ref child\n * @returns {undefined}\n */\n\nconst insertBefore = (newNode, refNode) => refNode && refNode.parentNode && refNode.parentNode.insertBefore(newNode, refNode);\n/**\n * Replace a node\n * @param {HTMLElement} newNode - new node to add to the DOM\n * @param {HTMLElement} replaced - node to replace\n * @returns {undefined}\n */\n\nconst replaceChild = (newNode, replaced) => replaced && replaced.parentNode && replaced.parentNode.replaceChild(newNode, replaced);\n\n// Riot.js constants that can be used accross more modules\nconst COMPONENTS_IMPLEMENTATION_MAP$1 = new Map(),\n      DOM_COMPONENT_INSTANCE_PROPERTY$1 = Symbol('riot-component'),\n      PLUGINS_SET$1 = new Set(),\n      IS_DIRECTIVE = 'is',\n      VALUE_ATTRIBUTE = 'value',\n      MOUNT_METHOD_KEY = 'mount',\n      UPDATE_METHOD_KEY = 'update',\n      UNMOUNT_METHOD_KEY = 'unmount',\n      SHOULD_UPDATE_KEY = 'shouldUpdate',\n      ON_BEFORE_MOUNT_KEY = 'onBeforeMount',\n      ON_MOUNTED_KEY = 'onMounted',\n      ON_BEFORE_UPDATE_KEY = 'onBeforeUpdate',\n      ON_UPDATED_KEY = 'onUpdated',\n      ON_BEFORE_UNMOUNT_KEY = 'onBeforeUnmount',\n      ON_UNMOUNTED_KEY = 'onUnmounted',\n      PROPS_KEY = 'props',\n      STATE_KEY = 'state',\n      SLOTS_KEY = 'slots',\n      ROOT_KEY = 'root',\n      IS_PURE_SYMBOL = Symbol('pure'),\n      IS_COMPONENT_UPDATING = Symbol('is_updating'),\n      PARENT_KEY_SYMBOL = Symbol('parent'),\n      ATTRIBUTES_KEY_SYMBOL = Symbol('attributes'),\n      TEMPLATE_KEY_SYMBOL = Symbol('template');\n\nvar globals = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  COMPONENTS_IMPLEMENTATION_MAP: COMPONENTS_IMPLEMENTATION_MAP$1,\n  DOM_COMPONENT_INSTANCE_PROPERTY: DOM_COMPONENT_INSTANCE_PROPERTY$1,\n  PLUGINS_SET: PLUGINS_SET$1,\n  IS_DIRECTIVE: IS_DIRECTIVE,\n  VALUE_ATTRIBUTE: VALUE_ATTRIBUTE,\n  MOUNT_METHOD_KEY: MOUNT_METHOD_KEY,\n  UPDATE_METHOD_KEY: UPDATE_METHOD_KEY,\n  UNMOUNT_METHOD_KEY: UNMOUNT_METHOD_KEY,\n  SHOULD_UPDATE_KEY: SHOULD_UPDATE_KEY,\n  ON_BEFORE_MOUNT_KEY: ON_BEFORE_MOUNT_KEY,\n  ON_MOUNTED_KEY: ON_MOUNTED_KEY,\n  ON_BEFORE_UPDATE_KEY: ON_BEFORE_UPDATE_KEY,\n  ON_UPDATED_KEY: ON_UPDATED_KEY,\n  ON_BEFORE_UNMOUNT_KEY: ON_BEFORE_UNMOUNT_KEY,\n  ON_UNMOUNTED_KEY: ON_UNMOUNTED_KEY,\n  PROPS_KEY: PROPS_KEY,\n  STATE_KEY: STATE_KEY,\n  SLOTS_KEY: SLOTS_KEY,\n  ROOT_KEY: ROOT_KEY,\n  IS_PURE_SYMBOL: IS_PURE_SYMBOL,\n  IS_COMPONENT_UPDATING: IS_COMPONENT_UPDATING,\n  PARENT_KEY_SYMBOL: PARENT_KEY_SYMBOL,\n  ATTRIBUTES_KEY_SYMBOL: ATTRIBUTES_KEY_SYMBOL,\n  TEMPLATE_KEY_SYMBOL: TEMPLATE_KEY_SYMBOL\n});\n\nconst EACH = 0;\nconst IF = 1;\nconst SIMPLE = 2;\nconst TAG = 3;\nconst SLOT = 4;\nvar bindingTypes = {\n  EACH,\n  IF,\n  SIMPLE,\n  TAG,\n  SLOT\n};\n\nconst ATTRIBUTE = 0;\nconst EVENT = 1;\nconst TEXT = 2;\nconst VALUE = 3;\nvar expressionTypes = {\n  ATTRIBUTE,\n  EVENT,\n  TEXT,\n  VALUE\n};\n\nconst HEAD_SYMBOL = Symbol('head');\nconst TAIL_SYMBOL = Symbol('tail');\n\n/**\n * Create the <template> fragments text nodes\n * @return {Object} {{head: Text, tail: Text}}\n */\n\nfunction createHeadTailPlaceholders() {\n  const head = document.createTextNode('');\n  const tail = document.createTextNode('');\n  head[HEAD_SYMBOL] = true;\n  tail[TAIL_SYMBOL] = true;\n  return {\n    head,\n    tail\n  };\n}\n\n/**\n * Create the template meta object in case of <template> fragments\n * @param   {TemplateChunk} componentTemplate - template chunk object\n * @returns {Object} the meta property that will be passed to the mount function of the TemplateChunk\n */\n\nfunction createTemplateMeta(componentTemplate) {\n  const fragment = componentTemplate.dom.cloneNode(true);\n  const {\n    head,\n    tail\n  } = createHeadTailPlaceholders();\n  return {\n    avoidDOMInjection: true,\n    fragment,\n    head,\n    tail,\n    children: [head, ...Array.from(fragment.childNodes), tail]\n  };\n}\n\n/**\n * Helper function to set an immutable property\n * @param   {Object} source - object where the new property will be set\n * @param   {string} key - object key where the new property will be stored\n * @param   {*} value - value of the new property\n * @param   {Object} options - set the propery overriding the default options\n * @returns {Object} - the original object modified\n */\nfunction defineProperty(source, key, value, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  /* eslint-disable fp/no-mutating-methods */\n  Object.defineProperty(source, key, Object.assign({\n    value,\n    enumerable: false,\n    writable: false,\n    configurable: true\n  }, options));\n  /* eslint-enable fp/no-mutating-methods */\n\n  return source;\n}\n/**\n * Define multiple properties on a target object\n * @param   {Object} source - object where the new properties will be set\n * @param   {Object} properties - object containing as key pair the key + value properties\n * @param   {Object} options - set the propery overriding the default options\n * @returns {Object} the original object modified\n */\n\nfunction defineProperties(source, properties, options) {\n  Object.entries(properties).forEach(_ref => {\n    let [key, value] = _ref;\n    defineProperty(source, key, value, options);\n  });\n  return source;\n}\n/**\n * Define default properties if they don't exist on the source object\n * @param   {Object} source - object that will receive the default properties\n * @param   {Object} defaults - object containing additional optional keys\n * @returns {Object} the original object received enhanced\n */\n\nfunction defineDefaults(source, defaults) {\n  Object.entries(defaults).forEach(_ref2 => {\n    let [key, value] = _ref2;\n    if (!source[key]) source[key] = value;\n  });\n  return source;\n}\n\n/**\n * Quick type checking\n * @param   {*} element - anything\n * @param   {string} type - type definition\n * @returns {boolean} true if the type corresponds\n */\nfunction checkType(element, type) {\n  return typeof element === type;\n}\n/**\n * Check if an element is part of an svg\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if we are in an svg context\n */\n\nfunction isSvg(el) {\n  const owner = el.ownerSVGElement;\n  return !!owner || owner === null;\n}\n/**\n * Check if an element is a template tag\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if it's a <template>\n */\n\nfunction isTemplate(el) {\n  return el.tagName.toLowerCase() === 'template';\n}\n/**\n * Check that will be passed if its argument is a function\n * @param   {*} value - value to check\n * @returns {boolean} - true if the value is a function\n */\n\nfunction isFunction(value) {\n  return checkType(value, 'function');\n}\n/**\n * Check if a value is a Boolean\n * @param   {*}  value - anything\n * @returns {boolean} true only for the value is a boolean\n */\n\nfunction isBoolean(value) {\n  return checkType(value, 'boolean');\n}\n/**\n * Check if a value is an Object\n * @param   {*}  value - anything\n * @returns {boolean} true only for the value is an object\n */\n\nfunction isObject(value) {\n  return !isNil(value) && value.constructor === Object;\n}\n/**\n * Check if a value is null or undefined\n * @param   {*}  value - anything\n * @returns {boolean} true only for the 'undefined' and 'null' types\n */\n\nfunction isNil(value) {\n  return value === null || value === undefined;\n}\n\n/**\n * ISC License\n *\n * Copyright (c) 2020, Andrea Giammarchi, @WebReflection\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n// fork of https://github.com/WebReflection/udomdiff version 1.1.0\n// due to https://github.com/WebReflection/udomdiff/pull/2\n\n/* eslint-disable */\n\n/**\n * @param {Node[]} a The list of current/live children\n * @param {Node[]} b The list of future children\n * @param {(entry: Node, action: number) => Node} get\n * The callback invoked per each entry related DOM operation.\n * @param {Node} [before] The optional node used as anchor to insert before.\n * @returns {Node[]} The same list of future children.\n */\n\nvar udomdiff = ((a, b, get, before) => {\n  const bLength = b.length;\n  let aEnd = a.length;\n  let bEnd = bLength;\n  let aStart = 0;\n  let bStart = 0;\n  let map = null;\n\n  while (aStart < aEnd || bStart < bEnd) {\n    // append head, tail, or nodes in between: fast path\n    if (aEnd === aStart) {\n      // we could be in a situation where the rest of nodes that\n      // need to be added are not at the end, and in such case\n      // the node to `insertBefore`, if the index is more than 0\n      // must be retrieved, otherwise it's gonna be the first item.\n      const node = bEnd < bLength ? bStart ? get(b[bStart - 1], -0).nextSibling : get(b[bEnd - bStart], 0) : before;\n\n      while (bStart < bEnd) insertBefore(get(b[bStart++], 1), node);\n    } // remove head or tail: fast path\n    else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        // remove the node only if it's unknown or not live\n        if (!map || !map.has(a[aStart])) removeChild(get(a[aStart], -1));\n        aStart++;\n      }\n    } // same node: fast path\n    else if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n    } // same tail: fast path\n    else if (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    } // The once here single last swap \"fast path\" has been removed in v1.1.0\n    // https://github.com/WebReflection/udomdiff/blob/single-final-swap/esm/index.js#L69-L85\n    // reverse swap: also fast path\n    else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {\n      // this is a \"shrink\" operation that could happen in these cases:\n      // [1, 2, 3, 4, 5]\n      // [1, 4, 3, 2, 5]\n      // or asymmetric too\n      // [1, 2, 3, 4, 5]\n      // [1, 2, 3, 5, 6, 4]\n      const node = get(a[--aEnd], -1).nextSibling;\n      insertBefore(get(b[bStart++], 1), get(a[aStart++], -1).nextSibling);\n      insertBefore(get(b[--bEnd], 1), node); // mark the future index as identical (yeah, it's dirty, but cheap 👍)\n      // The main reason to do this, is that when a[aEnd] will be reached,\n      // the loop will likely be on the fast path, as identical to b[bEnd].\n      // In the best case scenario, the next loop will skip the tail,\n      // but in the worst one, this node will be considered as already\n      // processed, bailing out pretty quickly from the map index check\n\n      a[aEnd] = b[bEnd];\n    } // map based fallback, \"slow\" path\n    else {\n      // the map requires an O(bEnd - bStart) operation once\n      // to store all future nodes indexes for later purposes.\n      // In the worst case scenario, this is a full O(N) cost,\n      // and such scenario happens at least when all nodes are different,\n      // but also if both first and last items of the lists are different\n      if (!map) {\n        map = new Map();\n        let i = bStart;\n\n        while (i < bEnd) map.set(b[i], i++);\n      } // if it's a future node, hence it needs some handling\n\n\n      if (map.has(a[aStart])) {\n        // grab the index of such node, 'cause it might have been processed\n        const index = map.get(a[aStart]); // if it's not already processed, look on demand for the next LCS\n\n        if (bStart < index && index < bEnd) {\n          let i = aStart; // counts the amount of nodes that are the same in the future\n\n          let sequence = 1;\n\n          while (++i < aEnd && i < bEnd && map.get(a[i]) === index + sequence) sequence++; // effort decision here: if the sequence is longer than replaces\n          // needed to reach such sequence, which would brings again this loop\n          // to the fast path, prepend the difference before a sequence,\n          // and move only the future list index forward, so that aStart\n          // and bStart will be aligned again, hence on the fast path.\n          // An example considering aStart and bStart are both 0:\n          // a: [1, 2, 3, 4]\n          // b: [7, 1, 2, 3, 6]\n          // this would place 7 before 1 and, from that time on, 1, 2, and 3\n          // will be processed at zero cost\n\n\n          if (sequence > index - bStart) {\n            const node = get(a[aStart], 0);\n\n            while (bStart < index) insertBefore(get(b[bStart++], 1), node);\n          } // if the effort wasn't good enough, fallback to a replace,\n          // moving both source and target indexes forward, hoping that some\n          // similar node will be found later on, to go back to the fast path\n          else {\n            replaceChild(get(b[bStart++], 1), get(a[aStart++], -1));\n          }\n        } // otherwise move the source forward, 'cause there's nothing to do\n        else aStart++;\n      } // this node has no meaning in the future list, so it's more than safe\n      // to remove it, and check the next live node out instead, meaning\n      // that only the live list index should be forwarded\n      else removeChild(get(a[aStart++], -1));\n    }\n  }\n\n  return b;\n});\n\nconst UNMOUNT_SCOPE = Symbol('unmount');\nconst EachBinding = {\n  // dynamic binding properties\n  // childrenMap: null,\n  // node: null,\n  // root: null,\n  // condition: null,\n  // evaluate: null,\n  // template: null,\n  // isTemplateTag: false,\n  nodes: [],\n\n  // getKey: null,\n  // indexName: null,\n  // itemName: null,\n  // afterPlaceholder: null,\n  // placeholder: null,\n  // API methods\n  mount(scope, parentScope) {\n    return this.update(scope, parentScope);\n  },\n\n  update(scope, parentScope) {\n    const {\n      placeholder,\n      nodes,\n      childrenMap\n    } = this;\n    const collection = scope === UNMOUNT_SCOPE ? null : this.evaluate(scope);\n    const items = collection ? Array.from(collection) : []; // prepare the diffing\n\n    const {\n      newChildrenMap,\n      batches,\n      futureNodes\n    } = createPatch(items, scope, parentScope, this); // patch the DOM only if there are new nodes\n\n    udomdiff(nodes, futureNodes, patch(Array.from(childrenMap.values()), parentScope), placeholder); // trigger the mounts and the updates\n\n    batches.forEach(fn => fn()); // update the children map\n\n    this.childrenMap = newChildrenMap;\n    this.nodes = futureNodes;\n    return this;\n  },\n\n  unmount(scope, parentScope) {\n    this.update(UNMOUNT_SCOPE, parentScope);\n    return this;\n  }\n\n};\n/**\n * Patch the DOM while diffing\n * @param   {any[]} redundant - list of all the children (template, nodes, context) added via each\n * @param   {*} parentScope - scope of the parent template\n * @returns {Function} patch function used by domdiff\n */\n\nfunction patch(redundant, parentScope) {\n  return (item, info) => {\n    if (info < 0) {\n      // get the last element added to the childrenMap saved previously\n      const element = redundant[redundant.length - 1];\n\n      if (element) {\n        // get the nodes and the template in stored in the last child of the childrenMap\n        const {\n          template,\n          nodes,\n          context\n        } = element; // remove the last node (notice <template> tags might have more children nodes)\n\n        nodes.pop(); // notice that we pass null as last argument because\n        // the root node and its children will be removed by domdiff\n\n        if (!nodes.length) {\n          // we have cleared all the children nodes and we can unmount this template\n          redundant.pop();\n          template.unmount(context, parentScope, null);\n        }\n      }\n    }\n\n    return item;\n  };\n}\n/**\n * Check whether a template must be filtered from a loop\n * @param   {Function} condition - filter function\n * @param   {Object} context - argument passed to the filter function\n * @returns {boolean} true if this item should be skipped\n */\n\n\nfunction mustFilterItem(condition, context) {\n  return condition ? !condition(context) : false;\n}\n/**\n * Extend the scope of the looped template\n * @param   {Object} scope - current template scope\n * @param   {Object} options - options\n * @param   {string} options.itemName - key to identify the looped item in the new context\n * @param   {string} options.indexName - key to identify the index of the looped item\n * @param   {number} options.index - current index\n * @param   {*} options.item - collection item looped\n * @returns {Object} enhanced scope object\n */\n\n\nfunction extendScope(scope, _ref) {\n  let {\n    itemName,\n    indexName,\n    index,\n    item\n  } = _ref;\n  defineProperty(scope, itemName, item);\n  if (indexName) defineProperty(scope, indexName, index);\n  return scope;\n}\n/**\n * Loop the current template items\n * @param   {Array} items - expression collection value\n * @param   {*} scope - template scope\n * @param   {*} parentScope - scope of the parent template\n * @param   {EachBinding} binding - each binding object instance\n * @returns {Object} data\n * @returns {Map} data.newChildrenMap - a Map containing the new children template structure\n * @returns {Array} data.batches - array containing the template lifecycle functions to trigger\n * @returns {Array} data.futureNodes - array containing the nodes we need to diff\n */\n\n\nfunction createPatch(items, scope, parentScope, binding) {\n  const {\n    condition,\n    template,\n    childrenMap,\n    itemName,\n    getKey,\n    indexName,\n    root,\n    isTemplateTag\n  } = binding;\n  const newChildrenMap = new Map();\n  const batches = [];\n  const futureNodes = [];\n  items.forEach((item, index) => {\n    const context = extendScope(Object.create(scope), {\n      itemName,\n      indexName,\n      index,\n      item\n    });\n    const key = getKey ? getKey(context) : index;\n    const oldItem = childrenMap.get(key);\n    const nodes = [];\n\n    if (mustFilterItem(condition, context)) {\n      return;\n    }\n\n    const mustMount = !oldItem;\n    const componentTemplate = oldItem ? oldItem.template : template.clone();\n    const el = componentTemplate.el || root.cloneNode();\n    const meta = isTemplateTag && mustMount ? createTemplateMeta(componentTemplate) : componentTemplate.meta;\n\n    if (mustMount) {\n      batches.push(() => componentTemplate.mount(el, context, parentScope, meta));\n    } else {\n      batches.push(() => componentTemplate.update(context, parentScope));\n    } // create the collection of nodes to update or to add\n    // in case of template tags we need to add all its children nodes\n\n\n    if (isTemplateTag) {\n      nodes.push(...meta.children);\n    } else {\n      nodes.push(el);\n    } // delete the old item from the children map\n\n\n    childrenMap.delete(key);\n    futureNodes.push(...nodes); // update the children map\n\n    newChildrenMap.set(key, {\n      nodes,\n      template: componentTemplate,\n      context,\n      index\n    });\n  });\n  return {\n    newChildrenMap,\n    batches,\n    futureNodes\n  };\n}\n\nfunction create$6(node, _ref2) {\n  let {\n    evaluate,\n    condition,\n    itemName,\n    indexName,\n    getKey,\n    template\n  } = _ref2;\n  const placeholder = document.createTextNode('');\n  const root = node.cloneNode();\n  insertBefore(placeholder, node);\n  removeChild(node);\n  return Object.assign({}, EachBinding, {\n    childrenMap: new Map(),\n    node,\n    root,\n    condition,\n    evaluate,\n    isTemplateTag: isTemplate(root),\n    template: template.createDOM(node),\n    getKey,\n    indexName,\n    itemName,\n    placeholder\n  });\n}\n\n/**\n * Binding responsible for the `if` directive\n */\n\nconst IfBinding = {\n  // dynamic binding properties\n  // node: null,\n  // evaluate: null,\n  // isTemplateTag: false,\n  // placeholder: null,\n  // template: null,\n  // API methods\n  mount(scope, parentScope) {\n    return this.update(scope, parentScope);\n  },\n\n  update(scope, parentScope) {\n    const value = !!this.evaluate(scope);\n    const mustMount = !this.value && value;\n    const mustUnmount = this.value && !value;\n\n    const mount = () => {\n      const pristine = this.node.cloneNode();\n      insertBefore(pristine, this.placeholder);\n      this.template = this.template.clone();\n      this.template.mount(pristine, scope, parentScope);\n    };\n\n    switch (true) {\n      case mustMount:\n        mount();\n        break;\n\n      case mustUnmount:\n        this.unmount(scope);\n        break;\n\n      default:\n        if (value) this.template.update(scope, parentScope);\n    }\n\n    this.value = value;\n    return this;\n  },\n\n  unmount(scope, parentScope) {\n    this.template.unmount(scope, parentScope, true);\n    return this;\n  }\n\n};\nfunction create$5(node, _ref) {\n  let {\n    evaluate,\n    template\n  } = _ref;\n  const placeholder = document.createTextNode('');\n  insertBefore(placeholder, node);\n  removeChild(node);\n  return Object.assign({}, IfBinding, {\n    node,\n    evaluate,\n    placeholder,\n    template: template.createDOM(node)\n  });\n}\n\n/**\n * Throw an error with a descriptive message\n * @param   { string } message - error message\n * @returns { undefined } hoppla.. at this point the program should stop working\n */\n\nfunction panic(message) {\n  throw new Error(message);\n}\n/**\n * Returns the memoized (cached) function.\n * // borrowed from https://www.30secondsofcode.org/js/s/memoize\n * @param {Function} fn - function to memoize\n * @returns {Function} memoize function\n */\n\nfunction memoize(fn) {\n  const cache = new Map();\n\n  const cached = val => {\n    return cache.has(val) ? cache.get(val) : cache.set(val, fn.call(this, val)) && cache.get(val);\n  };\n\n  cached.cache = cache;\n  return cached;\n}\n/**\n * Evaluate a list of attribute expressions\n * @param   {Array} attributes - attribute expressions generated by the riot compiler\n * @returns {Object} key value pairs with the result of the computation\n */\n\nfunction evaluateAttributeExpressions(attributes) {\n  return attributes.reduce((acc, attribute) => {\n    const {\n      value,\n      type\n    } = attribute;\n\n    switch (true) {\n      // spread attribute\n      case !attribute.name && type === ATTRIBUTE:\n        return Object.assign({}, acc, value);\n      // value attribute\n\n      case type === VALUE:\n        acc.value = attribute.value;\n        break;\n      // normal attributes\n\n      default:\n        acc[dashToCamelCase(attribute.name)] = attribute.value;\n    }\n\n    return acc;\n  }, {});\n}\n\nconst ElementProto = typeof Element === 'undefined' ? {} : Element.prototype;\nconst isNativeHtmlProperty = memoize(name => ElementProto.hasOwnProperty(name)); // eslint-disable-line\n\n/**\n * Add all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} attributes - object containing the attributes names and values\n * @returns {undefined} sorry it's a void function :(\n */\n\nfunction setAllAttributes(node, attributes) {\n  Object.entries(attributes).forEach(_ref => {\n    let [name, value] = _ref;\n    return attributeExpression(node, {\n      name\n    }, value);\n  });\n}\n/**\n * Remove all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} newAttributes - object containing all the new attribute names\n * @param   {Object} oldAttributes - object containing all the old attribute names\n * @returns {undefined} sorry it's a void function :(\n */\n\n\nfunction removeAllAttributes(node, newAttributes, oldAttributes) {\n  const newKeys = newAttributes ? Object.keys(newAttributes) : [];\n  Object.keys(oldAttributes).filter(name => !newKeys.includes(name)).forEach(attribute => node.removeAttribute(attribute));\n}\n/**\n * Check whether the attribute value can be rendered\n * @param {*} value - expression value\n * @returns {boolean} true if we can render this attribute value\n */\n\n\nfunction canRenderAttribute(value) {\n  return value === true || ['string', 'number'].includes(typeof value);\n}\n/**\n * Check whether the attribute should be removed\n * @param {*} value - expression value\n * @returns {boolean} boolean - true if the attribute can be removed}\n */\n\n\nfunction shouldRemoveAttribute(value) {\n  return !value && value !== 0;\n}\n/**\n * This methods handles the DOM attributes updates\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {string} expression.name - attribute name\n * @param   {*} value - new expression value\n * @param   {*} oldValue - the old expression cached value\n * @returns {undefined}\n */\n\n\nfunction attributeExpression(node, _ref2, value, oldValue) {\n  let {\n    name\n  } = _ref2;\n\n  // is it a spread operator? {...attributes}\n  if (!name) {\n    if (oldValue) {\n      // remove all the old attributes\n      removeAllAttributes(node, value, oldValue);\n    } // is the value still truthy?\n\n\n    if (value) {\n      setAllAttributes(node, value);\n    }\n\n    return;\n  } // handle boolean attributes\n\n\n  if (!isNativeHtmlProperty(name) && (isBoolean(value) || isObject(value) || isFunction(value))) {\n    node[name] = value;\n  }\n\n  if (shouldRemoveAttribute(value)) {\n    node.removeAttribute(name);\n  } else if (canRenderAttribute(value)) {\n    node.setAttribute(name, normalizeValue(name, value));\n  }\n}\n/**\n * Get the value as string\n * @param   {string} name - attribute name\n * @param   {*} value - user input value\n * @returns {string} input value as string\n */\n\nfunction normalizeValue(name, value) {\n  // be sure that expressions like selected={ true } will be always rendered as selected='selected'\n  return value === true ? name : value;\n}\n\nconst RE_EVENTS_PREFIX = /^on/;\n\nconst getCallbackAndOptions = value => Array.isArray(value) ? value : [value, false]; // see also https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38\n\n\nconst EventListener = {\n  handleEvent(event) {\n    this[event.type](event);\n  }\n\n};\nconst ListenersWeakMap = new WeakMap();\n\nconst createListener = node => {\n  const listener = Object.create(EventListener);\n  ListenersWeakMap.set(node, listener);\n  return listener;\n};\n/**\n * Set a new event listener\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {string} expression.name - event name\n * @param   {*} value - new expression value\n * @returns {value} the callback just received\n */\n\n\nfunction eventExpression(node, _ref, value) {\n  let {\n    name\n  } = _ref;\n  const normalizedEventName = name.replace(RE_EVENTS_PREFIX, '');\n  const eventListener = ListenersWeakMap.get(node) || createListener(node);\n  const [callback, options] = getCallbackAndOptions(value);\n  const handler = eventListener[normalizedEventName];\n  const mustRemoveEvent = handler && !callback;\n  const mustAddEvent = callback && !handler;\n\n  if (mustRemoveEvent) {\n    node.removeEventListener(normalizedEventName, eventListener);\n  }\n\n  if (mustAddEvent) {\n    node.addEventListener(normalizedEventName, eventListener, options);\n  }\n\n  eventListener[normalizedEventName] = callback;\n}\n\n/**\n * Normalize the user value in order to render a empty string in case of falsy values\n * @param   {*} value - user input value\n * @returns {string} hopefully a string\n */\n\nfunction normalizeStringValue(value) {\n  return isNil(value) ? '' : value;\n}\n\n/**\n * Get the the target text node to update or create one from of a comment node\n * @param   {HTMLElement} node - any html element containing childNodes\n * @param   {number} childNodeIndex - index of the text node in the childNodes list\n * @returns {Text} the text node to update\n */\n\nconst getTextNode = (node, childNodeIndex) => {\n  const target = node.childNodes[childNodeIndex];\n\n  if (target.nodeType === Node.COMMENT_NODE) {\n    const textNode = document.createTextNode('');\n    node.replaceChild(textNode, target);\n    return textNode;\n  }\n\n  return target;\n};\n/**\n * This methods handles a simple text expression update\n * @param   {HTMLElement} node - target node\n * @param   {Object} data - expression object\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\n\nfunction textExpression(node, data, value) {\n  node.data = normalizeStringValue(value);\n}\n\n/**\n * This methods handles the input fileds value updates\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\n\nfunction valueExpression(node, expression, value) {\n  node.value = normalizeStringValue(value);\n}\n\nvar expressions = {\n  [ATTRIBUTE]: attributeExpression,\n  [EVENT]: eventExpression,\n  [TEXT]: textExpression,\n  [VALUE]: valueExpression\n};\n\nconst Expression = {\n  // Static props\n  // node: null,\n  // value: null,\n  // API methods\n\n  /**\n   * Mount the expression evaluating its initial value\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  mount(scope) {\n    // hopefully a pure function\n    this.value = this.evaluate(scope); // IO() DOM updates\n\n    apply(this, this.value);\n    return this;\n  },\n\n  /**\n   * Update the expression if its value changed\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  update(scope) {\n    // pure function\n    const value = this.evaluate(scope);\n\n    if (this.value !== value) {\n      // IO() DOM updates\n      apply(this, value);\n      this.value = value;\n    }\n\n    return this;\n  },\n\n  /**\n   * Expression teardown method\n   * @returns {Expression} self\n   */\n  unmount() {\n    // unmount only the event handling expressions\n    if (this.type === EVENT) apply(this, null);\n    return this;\n  }\n\n};\n/**\n * IO() function to handle the DOM updates\n * @param {Expression} expression - expression object\n * @param {*} value - current expression value\n * @returns {undefined}\n */\n\nfunction apply(expression, value) {\n  return expressions[expression.type](expression.node, expression, value, expression.value);\n}\n\nfunction create$4(node, data) {\n  return Object.assign({}, Expression, data, {\n    node: data.type === TEXT ? getTextNode(node, data.childNodeIndex) : node\n  });\n}\n\n/**\n * Create a flat object having as keys a list of methods that if dispatched will propagate\n * on the whole collection\n * @param   {Array} collection - collection to iterate\n * @param   {Array<string>} methods - methods to execute on each item of the collection\n * @param   {*} context - context returned by the new methods created\n * @returns {Object} a new object to simplify the the nested methods dispatching\n */\nfunction flattenCollectionMethods(collection, methods, context) {\n  return methods.reduce((acc, method) => {\n    return Object.assign({}, acc, {\n      [method]: scope => {\n        return collection.map(item => item[method](scope)) && context;\n      }\n    });\n  }, {});\n}\n\nfunction create$3(node, _ref) {\n  let {\n    expressions\n  } = _ref;\n  return Object.assign({}, flattenCollectionMethods(expressions.map(expression => create$4(node, expression)), ['mount', 'update', 'unmount']));\n}\n\nfunction extendParentScope(attributes, scope, parentScope) {\n  if (!attributes || !attributes.length) return parentScope;\n  const expressions = attributes.map(attr => Object.assign({}, attr, {\n    value: attr.evaluate(scope)\n  }));\n  return Object.assign(Object.create(parentScope || null), evaluateAttributeExpressions(expressions));\n} // this function is only meant to fix an edge case\n// https://github.com/riot/riot/issues/2842\n\n\nconst getRealParent = (scope, parentScope) => scope[PARENT_KEY_SYMBOL] || parentScope;\n\nconst SlotBinding = {\n  // dynamic binding properties\n  // node: null,\n  // name: null,\n  attributes: [],\n\n  // template: null,\n  getTemplateScope(scope, parentScope) {\n    return extendParentScope(this.attributes, scope, parentScope);\n  },\n\n  // API methods\n  mount(scope, parentScope) {\n    const templateData = scope.slots ? scope.slots.find(_ref => {\n      let {\n        id\n      } = _ref;\n      return id === this.name;\n    }) : false;\n    const {\n      parentNode\n    } = this.node;\n    const realParent = getRealParent(scope, parentScope);\n    this.template = templateData && create(templateData.html, templateData.bindings).createDOM(parentNode);\n\n    if (this.template) {\n      cleanNode(this.node);\n      this.template.mount(this.node, this.getTemplateScope(scope, realParent), realParent);\n      this.template.children = Array.from(this.node.childNodes);\n    }\n\n    moveSlotInnerContent(this.node);\n    removeChild(this.node);\n    return this;\n  },\n\n  update(scope, parentScope) {\n    if (this.template) {\n      const realParent = getRealParent(scope, parentScope);\n      this.template.update(this.getTemplateScope(scope, realParent), realParent);\n    }\n\n    return this;\n  },\n\n  unmount(scope, parentScope, mustRemoveRoot) {\n    if (this.template) {\n      this.template.unmount(this.getTemplateScope(scope, parentScope), null, mustRemoveRoot);\n    }\n\n    return this;\n  }\n\n};\n/**\n * Move the inner content of the slots outside of them\n * @param   {HTMLElement} slot - slot node\n * @returns {undefined} it's a void method ¯\\_(ツ)_/¯\n */\n\nfunction moveSlotInnerContent(slot) {\n  const child = slot && slot.firstChild;\n  if (!child) return;\n  insertBefore(child, slot);\n  moveSlotInnerContent(slot);\n}\n/**\n * Create a single slot binding\n * @param   {HTMLElement} node - slot node\n * @param   {string} name - slot id\n * @param   {AttributeExpressionData[]} attributes - slot attributes\n * @returns {Object} Slot binding object\n */\n\n\nfunction createSlot(node, _ref2) {\n  let {\n    name,\n    attributes\n  } = _ref2;\n  return Object.assign({}, SlotBinding, {\n    attributes,\n    node,\n    name\n  });\n}\n\n/**\n * Create a new tag object if it was registered before, otherwise fallback to the simple\n * template chunk\n * @param   {Function} component - component factory function\n * @param   {Array<Object>} slots - array containing the slots markup\n * @param   {Array} attributes - dynamic attributes that will be received by the tag element\n * @returns {TagImplementation|TemplateChunk} a tag implementation or a template chunk as fallback\n */\n\nfunction getTag(component, slots, attributes) {\n  if (slots === void 0) {\n    slots = [];\n  }\n\n  if (attributes === void 0) {\n    attributes = [];\n  }\n\n  // if this tag was registered before we will return its implementation\n  if (component) {\n    return component({\n      slots,\n      attributes\n    });\n  } // otherwise we return a template chunk\n\n\n  return create(slotsToMarkup(slots), [...slotBindings(slots), {\n    // the attributes should be registered as binding\n    // if we fallback to a normal template chunk\n    expressions: attributes.map(attr => {\n      return Object.assign({\n        type: ATTRIBUTE\n      }, attr);\n    })\n  }]);\n}\n/**\n * Merge all the slots bindings into a single array\n * @param   {Array<Object>} slots - slots collection\n * @returns {Array<Bindings>} flatten bindings array\n */\n\n\nfunction slotBindings(slots) {\n  return slots.reduce((acc, _ref) => {\n    let {\n      bindings\n    } = _ref;\n    return acc.concat(bindings);\n  }, []);\n}\n/**\n * Merge all the slots together in a single markup string\n * @param   {Array<Object>} slots - slots collection\n * @returns {string} markup of all the slots in a single string\n */\n\n\nfunction slotsToMarkup(slots) {\n  return slots.reduce((acc, slot) => {\n    return acc + slot.html;\n  }, '');\n}\n\nconst TagBinding = {\n  // dynamic binding properties\n  // node: null,\n  // evaluate: null,\n  // name: null,\n  // slots: null,\n  // tag: null,\n  // attributes: null,\n  // getComponent: null,\n  mount(scope) {\n    return this.update(scope);\n  },\n\n  update(scope, parentScope) {\n    const name = this.evaluate(scope); // simple update\n\n    if (name && name === this.name) {\n      this.tag.update(scope);\n    } else {\n      // unmount the old tag if it exists\n      this.unmount(scope, parentScope, true); // mount the new tag\n\n      this.name = name;\n      this.tag = getTag(this.getComponent(name), this.slots, this.attributes);\n      this.tag.mount(this.node, scope);\n    }\n\n    return this;\n  },\n\n  unmount(scope, parentScope, keepRootTag) {\n    if (this.tag) {\n      // keep the root tag\n      this.tag.unmount(keepRootTag);\n    }\n\n    return this;\n  }\n\n};\nfunction create$2(node, _ref2) {\n  let {\n    evaluate,\n    getComponent,\n    slots,\n    attributes\n  } = _ref2;\n  return Object.assign({}, TagBinding, {\n    node,\n    evaluate,\n    slots,\n    attributes,\n    getComponent\n  });\n}\n\nvar bindings = {\n  [IF]: create$5,\n  [SIMPLE]: create$3,\n  [EACH]: create$6,\n  [TAG]: create$2,\n  [SLOT]: createSlot\n};\n\n/**\n * Text expressions in a template tag will get childNodeIndex value normalized\n * depending on the position of the <template> tag offset\n * @param   {Expression[]} expressions - riot expressions array\n * @param   {number} textExpressionsOffset - offset of the <template> tag\n * @returns {Expression[]} expressions containing the text expressions normalized\n */\n\nfunction fixTextExpressionsOffset(expressions, textExpressionsOffset) {\n  return expressions.map(e => e.type === TEXT ? Object.assign({}, e, {\n    childNodeIndex: e.childNodeIndex + textExpressionsOffset\n  }) : e);\n}\n/**\n * Bind a new expression object to a DOM node\n * @param   {HTMLElement} root - DOM node where to bind the expression\n * @param   {TagBindingData} binding - binding data\n * @param   {number|null} templateTagOffset - if it's defined we need to fix the text expressions childNodeIndex offset\n * @returns {Binding} Binding object\n */\n\n\nfunction create$1(root, binding, templateTagOffset) {\n  const {\n    selector,\n    type,\n    redundantAttribute,\n    expressions\n  } = binding; // find the node to apply the bindings\n\n  const node = selector ? root.querySelector(selector) : root; // remove eventually additional attributes created only to select this node\n\n  if (redundantAttribute) node.removeAttribute(redundantAttribute);\n  const bindingExpressions = expressions || []; // init the binding\n\n  return (bindings[type] || bindings[SIMPLE])(node, Object.assign({}, binding, {\n    expressions: templateTagOffset && !selector ? fixTextExpressionsOffset(bindingExpressions, templateTagOffset) : bindingExpressions\n  }));\n}\n\nfunction createHTMLTree(html, root) {\n  const template = isTemplate(root) ? root : document.createElement('template');\n  template.innerHTML = html;\n  return template.content;\n} // for svg nodes we need a bit more work\n\n\nfunction createSVGTree(html, container) {\n  // create the SVGNode\n  const svgNode = container.ownerDocument.importNode(new window.DOMParser().parseFromString(`<svg xmlns=\"http://www.w3.org/2000/svg\">${html}</svg>`, 'application/xml').documentElement, true);\n  return svgNode;\n}\n/**\n * Create the DOM that will be injected\n * @param {Object} root - DOM node to find out the context where the fragment will be created\n * @param   {string} html - DOM to create as string\n * @returns {HTMLDocumentFragment|HTMLElement} a new html fragment\n */\n\n\nfunction createDOMTree(root, html) {\n  if (isSvg(root)) return createSVGTree(html, root);\n  return createHTMLTree(html, root);\n}\n\n/**\n * Inject the DOM tree into a target node\n * @param   {HTMLElement} el - target element\n * @param   {DocumentFragment|SVGElement} dom - dom tree to inject\n * @returns {undefined}\n */\n\nfunction injectDOM(el, dom) {\n  switch (true) {\n    case isSvg(el):\n      moveChildren(dom, el);\n      break;\n\n    case isTemplate(el):\n      el.parentNode.replaceChild(dom, el);\n      break;\n\n    default:\n      el.appendChild(dom);\n  }\n}\n\n/**\n * Create the Template DOM skeleton\n * @param   {HTMLElement} el - root node where the DOM will be injected\n * @param   {string|HTMLElement} html - HTML markup or HTMLElement that will be injected into the root node\n * @returns {?DocumentFragment} fragment that will be injected into the root node\n */\n\nfunction createTemplateDOM(el, html) {\n  return html && (typeof html === 'string' ? createDOMTree(el, html) : html);\n}\n/**\n * Get the offset of the <template> tag\n * @param {HTMLElement} parentNode - template tag parent node\n * @param {HTMLElement} el - the template tag we want to render\n * @param   {Object} meta - meta properties needed to handle the <template> tags in loops\n * @returns {number} offset of the <template> tag calculated from its siblings DOM nodes\n */\n\n\nfunction getTemplateTagOffset(parentNode, el, meta) {\n  const siblings = Array.from(parentNode.childNodes);\n  return Math.max(siblings.indexOf(el), siblings.indexOf(meta.head) + 1, 0);\n}\n/**\n * Template Chunk model\n * @type {Object}\n */\n\n\nconst TemplateChunk = Object.freeze({\n  // Static props\n  // bindings: null,\n  // bindingsData: null,\n  // html: null,\n  // isTemplateTag: false,\n  // fragment: null,\n  // children: null,\n  // dom: null,\n  // el: null,\n\n  /**\n   * Create the template DOM structure that will be cloned on each mount\n   * @param   {HTMLElement} el - the root node\n   * @returns {TemplateChunk} self\n   */\n  createDOM(el) {\n    // make sure that the DOM gets created before cloning the template\n    this.dom = this.dom || createTemplateDOM(el, this.html) || document.createDocumentFragment();\n    return this;\n  },\n\n  // API methods\n\n  /**\n   * Attach the template to a DOM node\n   * @param   {HTMLElement} el - target DOM node\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @param   {Object} meta - meta properties needed to handle the <template> tags in loops\n   * @returns {TemplateChunk} self\n   */\n  mount(el, scope, parentScope, meta) {\n    if (meta === void 0) {\n      meta = {};\n    }\n\n    if (!el) throw new Error('Please provide DOM node to mount properly your template');\n    if (this.el) this.unmount(scope); // <template> tags require a bit more work\n    // the template fragment might be already created via meta outside of this call\n\n    const {\n      fragment,\n      children,\n      avoidDOMInjection\n    } = meta; // <template> bindings of course can not have a root element\n    // so we check the parent node to set the query selector bindings\n\n    const {\n      parentNode\n    } = children ? children[0] : el;\n    const isTemplateTag = isTemplate(el);\n    const templateTagOffset = isTemplateTag ? getTemplateTagOffset(parentNode, el, meta) : null; // create the DOM if it wasn't created before\n\n    this.createDOM(el); // create the DOM of this template cloning the original DOM structure stored in this instance\n    // notice that if a documentFragment was passed (via meta) we will use it instead\n\n    const cloneNode = fragment || this.dom.cloneNode(true); // store root node\n    // notice that for template tags the root note will be the parent tag\n\n    this.el = isTemplateTag ? parentNode : el; // create the children array only for the <template> fragments\n\n    this.children = isTemplateTag ? children || Array.from(cloneNode.childNodes) : null; // inject the DOM into the el only if a fragment is available\n\n    if (!avoidDOMInjection && cloneNode) injectDOM(el, cloneNode); // create the bindings\n\n    this.bindings = this.bindingsData.map(binding => create$1(this.el, binding, templateTagOffset));\n    this.bindings.forEach(b => b.mount(scope, parentScope)); // store the template meta properties\n\n    this.meta = meta;\n    return this;\n  },\n\n  /**\n   * Update the template with fresh data\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @returns {TemplateChunk} self\n   */\n  update(scope, parentScope) {\n    this.bindings.forEach(b => b.update(scope, parentScope));\n    return this;\n  },\n\n  /**\n   * Remove the template from the node where it was initially mounted\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @param   {boolean|null} mustRemoveRoot - if true remove the root element,\n   * if false or undefined clean the root tag content, if null don't touch the DOM\n   * @returns {TemplateChunk} self\n   */\n  unmount(scope, parentScope, mustRemoveRoot) {\n    if (mustRemoveRoot === void 0) {\n      mustRemoveRoot = false;\n    }\n\n    const el = this.el;\n\n    if (!el) {\n      return this;\n    }\n\n    this.bindings.forEach(b => b.unmount(scope, parentScope, mustRemoveRoot));\n\n    switch (true) {\n      // pure components should handle the DOM unmount updates by themselves\n      // for mustRemoveRoot === null don't touch the DOM\n      case el[IS_PURE_SYMBOL] || mustRemoveRoot === null:\n        break;\n      // if children are declared, clear them\n      // applicable for <template> and <slot/> bindings\n\n      case Array.isArray(this.children):\n        clearChildren(this.children);\n        break;\n      // clean the node children only\n\n      case !mustRemoveRoot:\n        cleanNode(el);\n        break;\n      // remove the root node only if the mustRemoveRoot is truly\n\n      case !!mustRemoveRoot:\n        removeChild(el);\n        break;\n    }\n\n    this.el = null;\n    return this;\n  },\n\n  /**\n   * Clone the template chunk\n   * @returns {TemplateChunk} a clone of this object resetting the this.el property\n   */\n  clone() {\n    return Object.assign({}, this, {\n      meta: {},\n      el: null\n    });\n  }\n\n});\n/**\n * Create a template chunk wiring also the bindings\n * @param   {string|HTMLElement} html - template string\n * @param   {BindingData[]} bindings - bindings collection\n * @returns {TemplateChunk} a new TemplateChunk copy\n */\n\nfunction create(html, bindings) {\n  if (bindings === void 0) {\n    bindings = [];\n  }\n\n  return Object.assign({}, TemplateChunk, {\n    html,\n    bindingsData: bindings\n  });\n}\n\n/**\n * Method used to bind expressions to a DOM node\n * @param   {string|HTMLElement} html - your static template html structure\n * @param   {Array} bindings - list of the expressions to bind to update the markup\n * @returns {TemplateChunk} a new TemplateChunk object having the `update`,`mount`, `unmount` and `clone` methods\n *\n * @example\n *\n * riotDOMBindings\n *  .template(\n *   `<div expr0><!----></div><div><p expr1><!----><section expr2></section></p>`,\n *   [\n *     {\n *       selector: '[expr0]',\n *       redundantAttribute: 'expr0',\n *       expressions: [\n *         {\n *           type: expressionTypes.TEXT,\n *           childNodeIndex: 0,\n *           evaluate(scope) {\n *             return scope.time;\n *           },\n *         },\n *       ],\n *     },\n *     {\n *       selector: '[expr1]',\n *       redundantAttribute: 'expr1',\n *       expressions: [\n *         {\n *           type: expressionTypes.TEXT,\n *           childNodeIndex: 0,\n *           evaluate(scope) {\n *             return scope.name;\n *           },\n *         },\n *         {\n *           type: 'attribute',\n *           name: 'style',\n *           evaluate(scope) {\n *             return scope.style;\n *           },\n *         },\n *       ],\n *     },\n *     {\n *       selector: '[expr2]',\n *       redundantAttribute: 'expr2',\n *       type: bindingTypes.IF,\n *       evaluate(scope) {\n *         return scope.isVisible;\n *       },\n *       template: riotDOMBindings.template('hello there'),\n *     },\n *   ]\n * )\n */\n\nvar DOMBindings = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  template: create,\n  createBinding: create$1,\n  createExpression: create$4,\n  bindingTypes: bindingTypes,\n  expressionTypes: expressionTypes\n});\n\nfunction noop() {\n  return this;\n}\n/**\n * Autobind the methods of a source object to itself\n * @param   {Object} source - probably a riot tag instance\n * @param   {Array<string>} methods - list of the methods to autobind\n * @returns {Object} the original object received\n */\n\nfunction autobindMethods(source, methods) {\n  methods.forEach(method => {\n    source[method] = source[method].bind(source);\n  });\n  return source;\n}\n/**\n * Call the first argument received only if it's a function otherwise return it as it is\n * @param   {*} source - anything\n * @returns {*} anything\n */\n\nfunction callOrAssign(source) {\n  return isFunction(source) ? source.prototype && source.prototype.constructor ? new source() : source() : source;\n}\n\n/**\n * Converts any DOM node/s to a loopable array\n * @param   { HTMLElement|NodeList } els - single html element or a node list\n * @returns { Array } always a loopable object\n */\nfunction domToArray(els) {\n  // can this object be already looped?\n  if (!Array.isArray(els)) {\n    // is it a node list?\n    if (/^\\[object (HTMLCollection|NodeList|Object)\\]$/.test(Object.prototype.toString.call(els)) && typeof els.length === 'number') return Array.from(els);else // if it's a single node\n      // it will be returned as \"array\" with one single entry\n      return [els];\n  } // this object could be looped out of the box\n\n\n  return els;\n}\n\n/**\n * Simple helper to find DOM nodes returning them as array like loopable object\n * @param   { string|DOMNodeList } selector - either the query or the DOM nodes to arraify\n * @param   { HTMLElement }        ctx      - context defining where the query will search for the DOM nodes\n * @returns { Array } DOM nodes found as array\n */\n\nfunction $(selector, ctx) {\n  return domToArray(typeof selector === 'string' ? (ctx || document).querySelectorAll(selector) : selector);\n}\n\n/**\n * Normalize the return values, in case of a single value we avoid to return an array\n * @param   { Array } values - list of values we want to return\n * @returns { Array|string|boolean } either the whole list of values or the single one found\n * @private\n */\n\nconst normalize = values => values.length === 1 ? values[0] : values;\n/**\n * Parse all the nodes received to get/remove/check their attributes\n * @param   { HTMLElement|NodeList|Array } els    - DOM node/s to parse\n * @param   { string|Array }               name   - name or list of attributes\n * @param   { string }                     method - method that will be used to parse the attributes\n * @returns { Array|string } result of the parsing in a list or a single value\n * @private\n */\n\n\nfunction parseNodes(els, name, method) {\n  const names = typeof name === 'string' ? [name] : name;\n  return normalize(domToArray(els).map(el => {\n    return normalize(names.map(n => el[method](n)));\n  }));\n}\n/**\n * Set any attribute on a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Object }              name  - either the name of the attribute to set\n *                                                 or a list of properties as object key - value\n * @param   { string }                     value - the new value of the attribute (optional)\n * @returns { HTMLElement|NodeList|Array } the original array of elements passed to this function\n *\n * @example\n *\n * import { set } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * set(img, 'width', 100)\n *\n * // or also\n * set(img, {\n *   width: 300,\n *   height: 300\n * })\n *\n */\n\n\nfunction set(els, name, value) {\n  const attrs = typeof name === 'object' ? name : {\n    [name]: value\n  };\n  const props = Object.keys(attrs);\n  domToArray(els).forEach(el => {\n    props.forEach(prop => el.setAttribute(prop, attrs[prop]));\n  });\n  return els;\n}\n/**\n * Get any attribute from a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Array }               name  - name or list of attributes to get\n * @returns { Array|string } list of the attributes found\n *\n * @example\n *\n * import { get } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * get(img, 'width') // => '200'\n *\n * // or also\n * get(img, ['width', 'height']) // => ['200', '300']\n *\n * // or also\n * get([img1, img2], ['width', 'height']) // => [['200', '300'], ['500', '200']]\n */\n\nfunction get(els, name) {\n  return parseNodes(els, name, 'getAttribute');\n}\n\nconst CSS_BY_NAME = new Map();\nconst STYLE_NODE_SELECTOR = 'style[riot]'; // memoized curried function\n\nconst getStyleNode = (style => {\n  return () => {\n    // lazy evaluation:\n    // if this function was already called before\n    // we return its cached result\n    if (style) return style; // create a new style element or use an existing one\n    // and cache it internally\n\n    style = $(STYLE_NODE_SELECTOR)[0] || document.createElement('style');\n    set(style, 'type', 'text/css');\n    /* istanbul ignore next */\n\n    if (!style.parentNode) document.head.appendChild(style);\n    return style;\n  };\n})();\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\n\n\nvar cssManager = {\n  CSS_BY_NAME,\n\n  /**\n   * Save a tag style to be later injected into DOM\n   * @param { string } name - if it's passed we will map the css to a tagname\n   * @param { string } css - css string\n   * @returns {Object} self\n   */\n  add(name, css) {\n    if (!CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.set(name, css);\n      this.inject();\n    }\n\n    return this;\n  },\n\n  /**\n   * Inject all previously saved tag styles into DOM\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   * @returns {Object} self\n   */\n  inject() {\n    getStyleNode().innerHTML = [...CSS_BY_NAME.values()].join('\\n');\n    return this;\n  },\n\n  /**\n   * Remove a tag style from the DOM\n   * @param {string} name a registered tagname\n   * @returns {Object} self\n   */\n  remove(name) {\n    if (CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.delete(name);\n      this.inject();\n    }\n\n    return this;\n  }\n\n};\n\n/**\n * Function to curry any javascript method\n * @param   {Function}  fn - the target function we want to curry\n * @param   {...[args]} acc - initial arguments\n * @returns {Function|*} it will return a function until the target function\n *                       will receive all of its arguments\n */\nfunction curry(fn) {\n  for (var _len = arguments.length, acc = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    acc[_key - 1] = arguments[_key];\n  }\n\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    args = [...acc, ...args];\n    return args.length < fn.length ? curry(fn, ...args) : fn(...args);\n  };\n}\n\n/**\n * Get the tag name of any DOM node\n * @param   {HTMLElement} element - DOM node we want to inspect\n * @returns {string} name to identify this dom node in riot\n */\n\nfunction getName(element) {\n  return get(element, IS_DIRECTIVE) || element.tagName.toLowerCase();\n}\n\nconst COMPONENT_CORE_HELPERS = Object.freeze({\n  // component helpers\n  $(selector) {\n    return $(selector, this.root)[0];\n  },\n\n  $$(selector) {\n    return $(selector, this.root);\n  }\n\n});\nconst PURE_COMPONENT_API = Object.freeze({\n  [MOUNT_METHOD_KEY]: noop,\n  [UPDATE_METHOD_KEY]: noop,\n  [UNMOUNT_METHOD_KEY]: noop\n});\nconst COMPONENT_LIFECYCLE_METHODS = Object.freeze({\n  [SHOULD_UPDATE_KEY]: noop,\n  [ON_BEFORE_MOUNT_KEY]: noop,\n  [ON_MOUNTED_KEY]: noop,\n  [ON_BEFORE_UPDATE_KEY]: noop,\n  [ON_UPDATED_KEY]: noop,\n  [ON_BEFORE_UNMOUNT_KEY]: noop,\n  [ON_UNMOUNTED_KEY]: noop\n});\nconst MOCKED_TEMPLATE_INTERFACE = Object.assign({}, PURE_COMPONENT_API, {\n  clone: noop,\n  createDOM: noop\n});\n/**\n * Performance optimization for the recursive components\n * @param  {RiotComponentWrapper} componentWrapper - riot compiler generated object\n * @returns {Object} component like interface\n */\n\nconst memoizedCreateComponent = memoize(createComponent);\n/**\n * Evaluate the component properties either from its real attributes or from its initial user properties\n * @param   {HTMLElement} element - component root\n * @param   {Object}  initialProps - initial props\n * @returns {Object} component props key value pairs\n */\n\nfunction evaluateInitialProps(element, initialProps) {\n  if (initialProps === void 0) {\n    initialProps = {};\n  }\n\n  return Object.assign({}, DOMattributesToObject(element), callOrAssign(initialProps));\n}\n/**\n * Bind a DOM node to its component object\n * @param   {HTMLElement} node - html node mounted\n * @param   {Object} component - Riot.js component object\n * @returns {Object} the component object received as second argument\n */\n\n\nconst bindDOMNodeToComponentObject = (node, component) => node[DOM_COMPONENT_INSTANCE_PROPERTY$1] = component;\n/**\n * Wrap the Riot.js core API methods using a mapping function\n * @param   {Function} mapFunction - lifting function\n * @returns {Object} an object having the { mount, update, unmount } functions\n */\n\n\nfunction createCoreAPIMethods(mapFunction) {\n  return [MOUNT_METHOD_KEY, UPDATE_METHOD_KEY, UNMOUNT_METHOD_KEY].reduce((acc, method) => {\n    acc[method] = mapFunction(method);\n    return acc;\n  }, {});\n}\n/**\n * Factory function to create the component templates only once\n * @param   {Function} template - component template creation function\n * @param   {RiotComponentWrapper} componentWrapper - riot compiler generated object\n * @returns {TemplateChunk} template chunk object\n */\n\n\nfunction componentTemplateFactory(template, componentWrapper) {\n  const components = createSubcomponents(componentWrapper.exports ? componentWrapper.exports.components : {});\n  return template(create, expressionTypes, bindingTypes, name => {\n    // improve support for recursive components\n    if (name === componentWrapper.name) return memoizedCreateComponent(componentWrapper); // return the registered components\n\n    return components[name] || COMPONENTS_IMPLEMENTATION_MAP$1.get(name);\n  });\n}\n/**\n * Create a pure component\n * @param   {Function} pureFactoryFunction - pure component factory function\n * @param   {Array} options.slots - component slots\n * @param   {Array} options.attributes - component attributes\n * @param   {Array} options.template - template factory function\n * @param   {Array} options.template - template factory function\n * @param   {any} options.props - initial component properties\n * @returns {Object} pure component object\n */\n\n\nfunction createPureComponent(pureFactoryFunction, _ref) {\n  let {\n    slots,\n    attributes,\n    props,\n    css,\n    template\n  } = _ref;\n  if (template) panic('Pure components can not have html');\n  if (css) panic('Pure components do not have css');\n  const component = defineDefaults(pureFactoryFunction({\n    slots,\n    attributes,\n    props\n  }), PURE_COMPONENT_API);\n  return createCoreAPIMethods(method => function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    // intercept the mount calls to bind the DOM node to the pure object created\n    // see also https://github.com/riot/riot/issues/2806\n    if (method === MOUNT_METHOD_KEY) {\n      const [element] = args; // mark this node as pure element\n\n      defineProperty(element, IS_PURE_SYMBOL, true);\n      bindDOMNodeToComponentObject(element, component);\n    }\n\n    component[method](...args);\n    return component;\n  });\n}\n/**\n * Create the component interface needed for the @riotjs/dom-bindings tag bindings\n * @param   {RiotComponentWrapper} componentWrapper - riot compiler generated object\n * @param   {string} componentWrapper.css - component css\n * @param   {Function} componentWrapper.template - function that will return the dom-bindings template function\n * @param   {Object} componentWrapper.exports - component interface\n * @param   {string} componentWrapper.name - component name\n * @returns {Object} component like interface\n */\n\n\nfunction createComponent(componentWrapper) {\n  const {\n    css,\n    template,\n    exports,\n    name\n  } = componentWrapper;\n  const templateFn = template ? componentTemplateFactory(template, componentWrapper) : MOCKED_TEMPLATE_INTERFACE;\n  return _ref2 => {\n    let {\n      slots,\n      attributes,\n      props\n    } = _ref2;\n    // pure components rendering will be managed by the end user\n    if (exports && exports[IS_PURE_SYMBOL]) return createPureComponent(exports, {\n      slots,\n      attributes,\n      props,\n      css,\n      template\n    });\n    const componentAPI = callOrAssign(exports) || {};\n    const component = defineComponent({\n      css,\n      template: templateFn,\n      componentAPI,\n      name\n    })({\n      slots,\n      attributes,\n      props\n    }); // notice that for the components create via tag binding\n    // we need to invert the mount (state/parentScope) arguments\n    // the template bindings will only forward the parentScope updates\n    // and never deal with the component state\n\n    return {\n      mount(element, parentScope, state) {\n        return component.mount(element, state, parentScope);\n      },\n\n      update(parentScope, state) {\n        return component.update(state, parentScope);\n      },\n\n      unmount(preserveRoot) {\n        return component.unmount(preserveRoot);\n      }\n\n    };\n  };\n}\n/**\n * Component definition function\n * @param   {Object} implementation - the componen implementation will be generated via compiler\n * @param   {Object} component - the component initial properties\n * @returns {Object} a new component implementation object\n */\n\nfunction defineComponent(_ref3) {\n  let {\n    css,\n    template,\n    componentAPI,\n    name\n  } = _ref3;\n  // add the component css into the DOM\n  if (css && name) cssManager.add(name, css);\n  return curry(enhanceComponentAPI)(defineProperties( // set the component defaults without overriding the original component API\n  defineDefaults(componentAPI, Object.assign({}, COMPONENT_LIFECYCLE_METHODS, {\n    [PROPS_KEY]: {},\n    [STATE_KEY]: {}\n  })), Object.assign({\n    // defined during the component creation\n    [SLOTS_KEY]: null,\n    [ROOT_KEY]: null\n  }, COMPONENT_CORE_HELPERS, {\n    name,\n    css,\n    template\n  })));\n}\n/**\n * Create the bindings to update the component attributes\n * @param   {HTMLElement} node - node where we will bind the expressions\n * @param   {Array} attributes - list of attribute bindings\n * @returns {TemplateChunk} - template bindings object\n */\n\nfunction createAttributeBindings(node, attributes) {\n  if (attributes === void 0) {\n    attributes = [];\n  }\n\n  const expressions = attributes.map(a => create$4(node, a));\n  const binding = {};\n  return Object.assign(binding, Object.assign({\n    expressions\n  }, createCoreAPIMethods(method => scope => {\n    expressions.forEach(e => e[method](scope));\n    return binding;\n  })));\n}\n/**\n * Create the subcomponents that can be included inside a tag in runtime\n * @param   {Object} components - components imported in runtime\n * @returns {Object} all the components transformed into Riot.Component factory functions\n */\n\n\nfunction createSubcomponents(components) {\n  if (components === void 0) {\n    components = {};\n  }\n\n  return Object.entries(callOrAssign(components)).reduce((acc, _ref4) => {\n    let [key, value] = _ref4;\n    acc[camelToDashCase(key)] = createComponent(value);\n    return acc;\n  }, {});\n}\n/**\n * Run the component instance through all the plugins set by the user\n * @param   {Object} component - component instance\n * @returns {Object} the component enhanced by the plugins\n */\n\n\nfunction runPlugins(component) {\n  return [...PLUGINS_SET$1].reduce((c, fn) => fn(c) || c, component);\n}\n/**\n * Compute the component current state merging it with its previous state\n * @param   {Object} oldState - previous state object\n * @param   {Object} newState - new state givent to the `update` call\n * @returns {Object} new object state\n */\n\n\nfunction computeState(oldState, newState) {\n  return Object.assign({}, oldState, callOrAssign(newState));\n}\n/**\n * Add eventually the \"is\" attribute to link this DOM node to its css\n * @param {HTMLElement} element - target root node\n * @param {string} name - name of the component mounted\n * @returns {undefined} it's a void function\n */\n\n\nfunction addCssHook(element, name) {\n  if (getName(element) !== name) {\n    set(element, IS_DIRECTIVE, name);\n  }\n}\n/**\n * Component creation factory function that will enhance the user provided API\n * @param   {Object} component - a component implementation previously defined\n * @param   {Array} options.slots - component slots generated via riot compiler\n * @param   {Array} options.attributes - attribute expressions generated via riot compiler\n * @returns {Riot.Component} a riot component instance\n */\n\n\nfunction enhanceComponentAPI(component, _ref5) {\n  let {\n    slots,\n    attributes,\n    props\n  } = _ref5;\n  return autobindMethods(runPlugins(defineProperties(isObject(component) ? Object.create(component) : component, {\n    mount(element, state, parentScope) {\n      if (state === void 0) {\n        state = {};\n      }\n\n      // any element mounted passing through this function can't be a pure component\n      defineProperty(element, IS_PURE_SYMBOL, false);\n      this[PARENT_KEY_SYMBOL] = parentScope;\n      this[ATTRIBUTES_KEY_SYMBOL] = createAttributeBindings(element, attributes).mount(parentScope);\n      defineProperty(this, PROPS_KEY, Object.freeze(Object.assign({}, evaluateInitialProps(element, props), evaluateAttributeExpressions(this[ATTRIBUTES_KEY_SYMBOL].expressions))));\n      this[STATE_KEY] = computeState(this[STATE_KEY], state);\n      this[TEMPLATE_KEY_SYMBOL] = this.template.createDOM(element).clone(); // link this object to the DOM node\n\n      bindDOMNodeToComponentObject(element, this); // add eventually the 'is' attribute\n\n      component.name && addCssHook(element, component.name); // define the root element\n\n      defineProperty(this, ROOT_KEY, element); // define the slots array\n\n      defineProperty(this, SLOTS_KEY, slots); // before mount lifecycle event\n\n      this[ON_BEFORE_MOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]); // mount the template\n\n      this[TEMPLATE_KEY_SYMBOL].mount(element, this, parentScope);\n      this[ON_MOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      return this;\n    },\n\n    update(state, parentScope) {\n      if (state === void 0) {\n        state = {};\n      }\n\n      if (parentScope) {\n        this[PARENT_KEY_SYMBOL] = parentScope;\n        this[ATTRIBUTES_KEY_SYMBOL].update(parentScope);\n      }\n\n      const newProps = evaluateAttributeExpressions(this[ATTRIBUTES_KEY_SYMBOL].expressions);\n      if (this[SHOULD_UPDATE_KEY](newProps, this[PROPS_KEY]) === false) return;\n      defineProperty(this, PROPS_KEY, Object.freeze(Object.assign({}, this[PROPS_KEY], newProps)));\n      this[STATE_KEY] = computeState(this[STATE_KEY], state);\n      this[ON_BEFORE_UPDATE_KEY](this[PROPS_KEY], this[STATE_KEY]); // avoiding recursive updates\n      // see also https://github.com/riot/riot/issues/2895\n\n      if (!this[IS_COMPONENT_UPDATING]) {\n        this[IS_COMPONENT_UPDATING] = true;\n        this[TEMPLATE_KEY_SYMBOL].update(this, this[PARENT_KEY_SYMBOL]);\n      }\n\n      this[ON_UPDATED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      this[IS_COMPONENT_UPDATING] = false;\n      return this;\n    },\n\n    unmount(preserveRoot) {\n      this[ON_BEFORE_UNMOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      this[ATTRIBUTES_KEY_SYMBOL].unmount(); // if the preserveRoot is null the template html will be left untouched\n      // in that case the DOM cleanup will happen differently from a parent node\n\n      this[TEMPLATE_KEY_SYMBOL].unmount(this, this[PARENT_KEY_SYMBOL], preserveRoot === null ? null : !preserveRoot);\n      this[ON_UNMOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      return this;\n    }\n\n  })), Object.keys(component).filter(prop => isFunction(component[prop])));\n}\n/**\n * Component initialization function starting from a DOM node\n * @param   {HTMLElement} element - element to upgrade\n * @param   {Object} initialProps - initial component properties\n * @param   {string} componentName - component id\n * @returns {Object} a new component instance bound to a DOM node\n */\n\nfunction mountComponent(element, initialProps, componentName) {\n  const name = componentName || getName(element);\n  if (!COMPONENTS_IMPLEMENTATION_MAP$1.has(name)) panic(`The component named \"${name}\" was never registered`);\n  const component = COMPONENTS_IMPLEMENTATION_MAP$1.get(name)({\n    props: initialProps\n  });\n  return component.mount(element);\n}\n\n/**\n * Similar to compose but performs from left-to-right function composition.<br/>\n * {@link https://30secondsofcode.org/function#composeright see also}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\n/**\n * Performs right-to-left function composition.<br/>\n * Use Array.prototype.reduce() to perform right-to-left function composition.<br/>\n * The last (rightmost) function can accept one or more arguments; the remaining functions must be unary.<br/>\n * {@link https://30secondsofcode.org/function#compose original source code}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\n\nfunction compose() {\n  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    fns[_key2] = arguments[_key2];\n  }\n\n  return fns.reduce((f, g) => function () {\n    return f(g(...arguments));\n  });\n}\n\nconst {\n  DOM_COMPONENT_INSTANCE_PROPERTY,\n  COMPONENTS_IMPLEMENTATION_MAP,\n  PLUGINS_SET\n} = globals;\n/**\n * Riot public api\n */\n\n/**\n * Register a custom tag by name\n * @param   {string} name - component name\n * @param   {Object} implementation - tag implementation\n * @returns {Map} map containing all the components implementations\n */\n\nfunction register(name, _ref) {\n  let {\n    css,\n    template,\n    exports\n  } = _ref;\n  if (COMPONENTS_IMPLEMENTATION_MAP.has(name)) panic(`The component \"${name}\" was already registered`);\n  COMPONENTS_IMPLEMENTATION_MAP.set(name, createComponent({\n    name,\n    css,\n    template,\n    exports\n  }));\n  return COMPONENTS_IMPLEMENTATION_MAP;\n}\n/**\n * Unregister a riot web component\n * @param   {string} name - component name\n * @returns {Map} map containing all the components implementations\n */\n\nfunction unregister(name) {\n  if (!COMPONENTS_IMPLEMENTATION_MAP.has(name)) panic(`The component \"${name}\" was never registered`);\n  COMPONENTS_IMPLEMENTATION_MAP.delete(name);\n  cssManager.remove(name);\n  return COMPONENTS_IMPLEMENTATION_MAP;\n}\n/**\n * Mounting function that will work only for the components that were globally registered\n * @param   {string|HTMLElement} selector - query for the selection or a DOM element\n * @param   {Object} initialProps - the initial component properties\n * @param   {string} name - optional component name\n * @returns {Array} list of riot components\n */\n\nfunction mount(selector, initialProps, name) {\n  return $(selector).map(element => mountComponent(element, initialProps, name));\n}\n/**\n * Sweet unmounting helper function for the DOM node mounted manually by the user\n * @param   {string|HTMLElement} selector - query for the selection or a DOM element\n * @param   {boolean|null} keepRootElement - if true keep the root element\n * @returns {Array} list of nodes unmounted\n */\n\nfunction unmount(selector, keepRootElement) {\n  return $(selector).map(element => {\n    if (element[DOM_COMPONENT_INSTANCE_PROPERTY]) {\n      element[DOM_COMPONENT_INSTANCE_PROPERTY].unmount(keepRootElement);\n    }\n\n    return element;\n  });\n}\n/**\n * Define a riot plugin\n * @param   {Function} plugin - function that will receive all the components created\n * @returns {Set} the set containing all the plugins installed\n */\n\nfunction install(plugin) {\n  if (!isFunction(plugin)) panic('Plugins must be of type function');\n  if (PLUGINS_SET.has(plugin)) panic('This plugin was already installed');\n  PLUGINS_SET.add(plugin);\n  return PLUGINS_SET;\n}\n/**\n * Uninstall a riot plugin\n * @param   {Function} plugin - plugin previously installed\n * @returns {Set} the set containing all the plugins installed\n */\n\nfunction uninstall(plugin) {\n  if (!PLUGINS_SET.has(plugin)) panic('This plugin was never installed');\n  PLUGINS_SET.delete(plugin);\n  return PLUGINS_SET;\n}\n/**\n * Helper method to create component without relying on the registered ones\n * @param   {Object} implementation - component implementation\n * @returns {Function} function that will allow you to mount a riot component on a DOM node\n */\n\nfunction component(implementation) {\n  return function (el, props, _temp) {\n    let {\n      slots,\n      attributes,\n      parentScope\n    } = _temp === void 0 ? {} : _temp;\n    return compose(c => c.mount(el, parentScope), c => c({\n      props,\n      slots,\n      attributes\n    }), createComponent)(implementation);\n  };\n}\n/**\n * Lift a riot component Interface into a pure riot object\n * @param   {Function} func - RiotPureComponent factory function\n * @returns {Function} the lifted original function received as argument\n */\n\nfunction pure(func) {\n  if (!isFunction(func)) panic('riot.pure accepts only arguments of type \"function\"');\n  func[IS_PURE_SYMBOL] = true;\n  return func;\n}\n/**\n * no-op function needed to add the proper types to your component via typescript\n * @param {Function|Object} component - component default export\n * @returns {Function|Object} returns exactly what it has received\n */\n\nconst withTypes = component => component;\n/** @type {string} current riot version */\n\nconst version = 'v6.1.2'; // expose some internal stuff that might be used from external tools\n\nconst __ = {\n  cssManager,\n  DOMBindings,\n  createComponent,\n  defineComponent,\n  globals\n};\n\nexport { __, component, install, mount, pure, register, uninstall, unmount, unregister, version, withTypes };\n","import memoize from \"./memoize\";\n\n// import { fromPredicate, map, Option } from \"fp-ts/lib/Option\";\nexport type GameOfLifeSettings = {\n    /** number of cells adjacent for alive cell to survive */\n    surviveAdjacent: number[];\n    /** number of cells adjacent for dead cell to be alive */\n    reproAdjacent: number[];\n    loop: boolean;\n};\nexport type Cells = boolean[][];\n// export const getCellOption = fromPredicate((b: Cells) => Array.isArray(b) && b.length > 0)\nexport const processGameOfLife = (\nsettings: GameOfLifeSettings,\ncells: Cells\n) => {\nconst newCells: boolean[][] = cells.map((x) => x.slice());\ncells.forEach((xcells, xi) =>\n    xcells.forEach((ycell, yi) => {\n    newCells[xi][yi] = cells[xi][yi]\n        ? checkSurvive(\n            settings.surviveAdjacent,\n            getAdjacentValues(xi, yi, cells)\n        )\n        : checkRepro(settings.reproAdjacent, getAdjacentValues(xi, yi, cells));\n    })\n);\nreturn newCells;\n};\n\nconst getMaxX = (cells: Cells) => cells.length;\nconst getMaxY = (cells: Cells) => cells[0].length;\n// const getMaxXOpt = map(getMaxX)\n// const getMaxYOpt = map(getMaxY)\nconst getAdjacentIndexes = memoize((x: number, y: number, maxX: number, maxY: number) => {\n    let startX = x - 1;\n    let startY = y - 1;\n    startX = startX < 0 ? maxX + startX : startX;\n    startY = startY < 0 ? maxY + startY : startY;\n    let adjacentIndexes: [number, number][] = [];\n    for (let xi = 0; xi < 3; xi++) {\n        for (let yi = 0; yi < 3; yi++) {\n        const currentX = (startX + xi) % maxX;\n        const currentY = (startY + yi) % maxY;\n        if (currentX === x && currentY === y) {\n            continue;\n        }\n            adjacentIndexes.push([currentX, currentY]);\n        }\n    }\n    return adjacentIndexes;\n})\nconst getAdjacentValues = (x: number, y: number, cells: Cells) => {\n    const maxX = getMaxX(cells);\n    const maxY = getMaxY(cells);\n    let indexes = getAdjacentIndexes(x, y, maxX, maxY)\n    return indexes?.map(x => cells[x[0]][x[1]])\n};\nconst getAliveAdjacent = (adjacentValues: boolean[]) => adjacentValues.reduce(\n    (acc, curr) => acc + (curr ? 1 : 0),\n    0\n);\nconst checkSurvive = (surviveCounts: number[], adjacentValues: boolean[]) => {\n    return surviveCounts.some((x) => x === getAliveAdjacent(adjacentValues));\n};\nconst checkRepro = (reproCounts: number[], adjacentValues: boolean[]) => {\n    return reproCounts.some((x) => x === getAliveAdjacent(adjacentValues));\n};\n\nexport const createCells = (x: number, y: number) => {\n    let arr: Cells = [];\n    for (let i = 0; i < x; i++) {\n      arr.push([]);\n      for (let j = 0; j < y; j++) {\n        arr[i].push(Math.random() * 1 > 0.5);\n      }\n    }\n    return arr;\n};","export default function memoize<T extends (...args: any) => any>(fn: T): (...args: Parameters<T>) => ReturnType<T> {\n    const keyValue = new Map<string, ReturnType<T>>();\n    return (...args: T[]) => {\n      const key = createKey(...args);\n      if (keyValue.has(key)) {\n        return keyValue.get(key) as ReturnType<T>;\n      } else {\n        const value = fn(...args);\n        keyValue.set(key,value)\n        return value;\n      }\n    };\n  }\n  function createKey(...args: any[]) {\n    return JSON.stringify(args);\n  }\n  ","<game-of-life class=\"flex gap-1\">\n    <!-- <template each={ row in state.gameState }>\n        <game-cell each={cell in row} alive={cell}></game-cell>\n    </template> -->\n    <div class=\"flex flex-col gap-1\" each={ row in state.gameState }>\n        <game-cell each={cell in row} alive={cell}></game-cell>\n    </div>\n    <!-- <pre>{JSON.stringify(state.gameState)}</pre> -->\n    <script lang=\"ts\">\n        import {createCells, processGameOfLife} from '../../utils/game-of-life'\n        import GameCell from './game-cell.riot'\n        const settings = {\n            surviveAdjacent: [2,3],\n            reproAdjacent: [3]\n        }\n        const tickMs = 200;\n        const size = [100,100]\n        export default {\n            state: {\n                gameState: [],\n                timeoutId: undefined\n            },\n            onBeforeMount(props, state) {\n                const tick = () => {\n                    this.update({\n                        gameState: processGameOfLife(settings, this.state.gameState),\n                        timeoutId: setTimeout(() => {\n                            tick()\n                        }, tickMs)\n                    })\n                }\n                this.state = {\n                    gameState: createCells(...size),\n                    timeoutId: setTimeout(() => {\n                        tick()\n                    }, tickMs)\n                }\n            },\n            onBeforeUnmount(props, state) {\n                clearTimeout(this.state.timeoutId)\n            },\n            components: {\n                GameCell\n            }\n        }\n    </script>\n</game-of-life>","<app class=\"\">\n    <main-banner></main-banner>\n    <script>\n        import MainBanner from './components/main-banner/main-banner.riot'\n        export default {\n            components: {\n                MainBanner\n            }\n        }\n    </script>\n</app>","<main-banner>\n    <section class=\"flex\">\n        <component-background>\n            <game-of-life slot=\"background\"></game-of-life>\n            <header-text>Kevin something!</header-text>\n        </component-background>\n    </section>\n\n    <script>\n        import HeaderText from \"../header-text/header-text.riot\"\n        import GameOfLife from '../game-of-life/game-of-life.riot'\n        import ComponentBackground from \"../component-background/component-background.riot\"\n        export default {\n            components: {\n                HeaderText,\n                GameOfLife,\n                ComponentBackground\n            }\n        }\n    </script>\n</main-banner>","<header-text class=\"text-2xl font-bold\">\n    <slot/>\n</header-text>","\n<game-cell class=\"{props.alive ? 'bg-slate-500' : 'bg-transparent'} block w-4 h-4\">\n    &nbsp;\n    <script>\n        export default {\n            shouldUpdate(newP, currP) {\n                return newP.alive !== currP.alive;\n            }\n        }\n    </script>\n</game-cell>","<component-background class=\"relative\">\n    <div class=\"absolute inset-0\">\n        <slot name=\"background\" />\n    </div>\n    <slot />\n</component-background>","import * as riot from 'riot'\nimport App from './app.riot'\n\nconst mountApp = riot.component(App)\nconst app = mountApp(\n    document.getElementById('root'),\n    { message: 'Hello world'}\n)"],"names":["$11f9b7ede6cb0357$var$dashToCamelCase","string","replace","_","c","toUpperCase","$11f9b7ede6cb0357$var$moveChildren","source","target","firstChild","appendChild","$11f9b7ede6cb0357$var$cleanNode","node","$11f9b7ede6cb0357$var$clearChildren","childNodes","children","Array","from","forEach","$11f9b7ede6cb0357$var$removeChild","parentNode","removeChild","$11f9b7ede6cb0357$var$insertBefore","newNode","refNode","insertBefore","$11f9b7ede6cb0357$var$COMPONENTS_IMPLEMENTATION_MAP$1","Map","$11f9b7ede6cb0357$var$DOM_COMPONENT_INSTANCE_PROPERTY$1","Symbol","$11f9b7ede6cb0357$var$PLUGINS_SET$1","Set","$11f9b7ede6cb0357$var$MOUNT_METHOD_KEY","$11f9b7ede6cb0357$var$UPDATE_METHOD_KEY","$11f9b7ede6cb0357$var$UNMOUNT_METHOD_KEY","$11f9b7ede6cb0357$var$IS_PURE_SYMBOL","$11f9b7ede6cb0357$var$IS_COMPONENT_UPDATING","$11f9b7ede6cb0357$var$PARENT_KEY_SYMBOL","$11f9b7ede6cb0357$var$ATTRIBUTES_KEY_SYMBOL","$11f9b7ede6cb0357$var$TEMPLATE_KEY_SYMBOL","$11f9b7ede6cb0357$var$globals","Object","freeze","__proto__","COMPONENTS_IMPLEMENTATION_MAP","DOM_COMPONENT_INSTANCE_PROPERTY","PLUGINS_SET","IS_DIRECTIVE","VALUE_ATTRIBUTE","MOUNT_METHOD_KEY","UPDATE_METHOD_KEY","UNMOUNT_METHOD_KEY","SHOULD_UPDATE_KEY","ON_BEFORE_MOUNT_KEY","ON_MOUNTED_KEY","ON_BEFORE_UPDATE_KEY","ON_UPDATED_KEY","ON_BEFORE_UNMOUNT_KEY","ON_UNMOUNTED_KEY","PROPS_KEY","STATE_KEY","SLOTS_KEY","ROOT_KEY","IS_PURE_SYMBOL","IS_COMPONENT_UPDATING","PARENT_KEY_SYMBOL","ATTRIBUTES_KEY_SYMBOL","TEMPLATE_KEY_SYMBOL","$11f9b7ede6cb0357$var$bindingTypes","$11f9b7ede6cb0357$var$expressionTypes","$11f9b7ede6cb0357$var$HEAD_SYMBOL","$11f9b7ede6cb0357$var$TAIL_SYMBOL","$11f9b7ede6cb0357$var$createTemplateMeta","componentTemplate","fragment","dom","cloneNode","head","tail","document","createTextNode","$11f9b7ede6cb0357$var$createHeadTailPlaceholders","avoidDOMInjection","$11f9b7ede6cb0357$var$defineProperty","key","value","options","defineProperty","assign","enumerable","writable","configurable","$11f9b7ede6cb0357$var$defineProperties","properties","entries","_ref","$11f9b7ede6cb0357$var$defineDefaults","defaults","_ref2","$11f9b7ede6cb0357$var$checkType","element","type","$11f9b7ede6cb0357$var$isSvg","el","owner","ownerSVGElement","$11f9b7ede6cb0357$var$isTemplate","tagName","toLowerCase","$11f9b7ede6cb0357$var$isFunction","$11f9b7ede6cb0357$var$isObject","$11f9b7ede6cb0357$var$isNil","constructor","$11f9b7ede6cb0357$var$UNMOUNT_SCOPE","$11f9b7ede6cb0357$var$EachBinding","nodes","mount","scope","parentScope","this","update","placeholder","childrenMap","collection","evaluate","items","newChildrenMap","batches","futureNodes","binding","condition","template","itemName","getKey","indexName","root","isTemplateTag","item","index","context","$11f9b7ede6cb0357$var$extendScope","create","oldItem","get","$11f9b7ede6cb0357$var$mustFilterItem","mustMount","clone","meta","push","delete","set","$11f9b7ede6cb0357$var$createPatch","a","b","get1","before","bLength","length","aEnd","bEnd","aStart","bStart","map","nextSibling","has","i","sequence","replaced","replaceChild","$11f9b7ede6cb0357$var$udomdiff","redundant","info","pop","unmount","$11f9b7ede6cb0357$var$patch","values","fn","$11f9b7ede6cb0357$var$IfBinding","mustUnmount","mount1","pristine","$11f9b7ede6cb0357$var$panic","message","Error","$11f9b7ede6cb0357$var$memoize","cache","cached","val","call","$11f9b7ede6cb0357$var$evaluateAttributeExpressions","attributes","reduce","acc","attribute","name","$11f9b7ede6cb0357$var$ElementProto","Element","prototype","$11f9b7ede6cb0357$var$isNativeHtmlProperty","hasOwnProperty","$11f9b7ede6cb0357$var$attributeExpression","oldValue","newAttributes","oldAttributes","newKeys","keys","filter","includes","removeAttribute","$11f9b7ede6cb0357$var$removeAllAttributes","$11f9b7ede6cb0357$var$setAllAttributes","$11f9b7ede6cb0357$var$isBoolean","$11f9b7ede6cb0357$var$shouldRemoveAttribute","$11f9b7ede6cb0357$var$canRenderAttribute","setAttribute","$11f9b7ede6cb0357$var$normalizeValue","$11f9b7ede6cb0357$var$RE_EVENTS_PREFIX","$11f9b7ede6cb0357$var$EventListener","handleEvent","event","$11f9b7ede6cb0357$var$ListenersWeakMap","WeakMap","$11f9b7ede6cb0357$var$normalizeStringValue","$11f9b7ede6cb0357$var$getTextNode","childNodeIndex","nodeType","Node","COMMENT_NODE","textNode","$11f9b7ede6cb0357$var$expressions","normalizedEventName","eventListener","listener","$11f9b7ede6cb0357$var$createListener","callback","isArray","$11f9b7ede6cb0357$var$getCallbackAndOptions","handler","mustAddEvent","removeEventListener","addEventListener","data","expression","$11f9b7ede6cb0357$var$Expression","$11f9b7ede6cb0357$var$apply","$11f9b7ede6cb0357$var$create$4","$11f9b7ede6cb0357$var$getRealParent","$11f9b7ede6cb0357$var$SlotBinding","getTemplateScope","expressions2","attr","$11f9b7ede6cb0357$var$extendParentScope","templateData","slots","find","id","realParent","$11f9b7ede6cb0357$var$create","html","bindings","createDOM","$11f9b7ede6cb0357$var$moveSlotInnerContent","mustRemoveRoot","slot","child","$11f9b7ede6cb0357$var$slotBindings","bindings1","concat","$11f9b7ede6cb0357$var$TagBinding","component1","tag","getComponent","$11f9b7ede6cb0357$var$slotsToMarkup","expressions","keepRootTag","$11f9b7ede6cb0357$var$bindings","expressions1","method","$11f9b7ede6cb0357$var$create$1","templateTagOffset","selector","redundantAttribute","expressions4","querySelector","bindingExpressions","expressions3","textExpressionsOffset","e","$11f9b7ede6cb0357$var$createDOMTree","container","ownerDocument","importNode","window","DOMParser","parseFromString","documentElement","$11f9b7ede6cb0357$var$createSVGTree","createElement","innerHTML","content","$11f9b7ede6cb0357$var$createHTMLTree","$11f9b7ede6cb0357$var$injectDOM","$11f9b7ede6cb0357$var$TemplateChunk","$11f9b7ede6cb0357$var$createTemplateDOM","createDocumentFragment","siblings","Math","max","indexOf","$11f9b7ede6cb0357$var$getTemplateTagOffset","bindingsData","bindings2","$11f9b7ede6cb0357$var$noop","$11f9b7ede6cb0357$var$callOrAssign","$11f9b7ede6cb0357$var$domToArray","els","test","toString","$11f9b7ede6cb0357$var$$","ctx","querySelectorAll","$11f9b7ede6cb0357$var$normalize","$11f9b7ede6cb0357$var$set","attrs","props","prop","$11f9b7ede6cb0357$var$get","names","n","$11f9b7ede6cb0357$var$parseNodes","$11f9b7ede6cb0357$var$CSS_BY_NAME","$11f9b7ede6cb0357$var$getStyleNode","style","$11f9b7ede6cb0357$var$cssManager","add","css","inject","join","remove","$11f9b7ede6cb0357$var$curry","_len","arguments","_key","_len2","args","_key2","$11f9b7ede6cb0357$var$getName","$11f9b7ede6cb0357$var$COMPONENT_CORE_HELPERS","$","$$","$11f9b7ede6cb0357$var$PURE_COMPONENT_API","$11f9b7ede6cb0357$var$COMPONENT_LIFECYCLE_METHODS","shouldUpdate","onBeforeMount","onMounted","onBeforeUpdate","onUpdated","onBeforeUnmount","onUnmounted","$11f9b7ede6cb0357$var$MOCKED_TEMPLATE_INTERFACE","$11f9b7ede6cb0357$var$memoizedCreateComponent","$11f9b7ede6cb0357$var$createComponent","$11f9b7ede6cb0357$var$evaluateInitialProps","initialProps","$11f9b7ede6cb0357$var$DOMattributesToObject","$11f9b7ede6cb0357$var$bindDOMNodeToComponentObject","component2","$11f9b7ede6cb0357$var$createCoreAPIMethods","mapFunction","$11f9b7ede6cb0357$var$componentTemplateFactory","componentWrapper","components","_ref4","$11f9b7ede6cb0357$var$createSubcomponents","exports","templateFn","pureFactoryFunction","component3","$11f9b7ede6cb0357$var$createPureComponent","componentAPI","component4","$11f9b7ede6cb0357$var$defineComponent","state","preserveRoot","_ref3","$11f9b7ede6cb0357$var$enhanceComponentAPI","$11f9b7ede6cb0357$var$computeState","oldState","newState","component6","_ref5","component5","expressions5","$11f9b7ede6cb0357$var$createAttributeBindings","$11f9b7ede6cb0357$var$addCssHook","newProps","bind","$11f9b7ede6cb0357$var$DOM_COMPONENT_INSTANCE_PROPERTY","$11f9b7ede6cb0357$var$COMPONENTS_IMPLEMENTATION_MAP","$11f9b7ede6cb0357$var$PLUGINS_SET","$c0d136ae6836b3ee$export$f3e3452c589838f5","settings","cells","newCells","x","slice","xcells","xi","ycell","yi","$c0d136ae6836b3ee$var$checkSurvive","surviveAdjacent","$c0d136ae6836b3ee$var$getAdjacentValues","$c0d136ae6836b3ee$var$checkRepro","reproAdjacent","$c0d136ae6836b3ee$var$getAdjacentIndexes","keyValue","JSON","stringify","$558d8a7788a45952$var$createKey","y","maxX","maxY","startX","startY","adjacentIndexes","currentX","currentY","x1","$c0d136ae6836b3ee$var$getMaxX","$c0d136ae6836b3ee$var$getMaxY","$c0d136ae6836b3ee$var$getAliveAdjacent","adjacentValues","curr","surviveCounts","some","reproCounts","$c0d136ae6836b3ee$export$a4ea2734911f525f","arr","j","random","$e9edaf5969c00a7f$var$settings","$e9edaf5969c00a7f$var$size","implementation","_scope","gameState","timeoutId","undefined","tick","setTimeout","clearTimeout","newP","currP","alive","cell","_temp","fns","f","g","$11f9b7ede6cb0357$var$compose","getElementById"],"version":3,"file":"index.e6602843.js.map"}